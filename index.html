<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Matrix Point-Cloud (Webcam)</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #out{position:fixed;inset:0;display:block;width:100vw;height:100vh}
  #v{display:none}
  /* Fallback click-to-start overlay if autoplay is blocked */
  #gate{
    position:fixed;inset:0;display:none;place-items:center;
    background:rgba(0,0,0,.9);color:#00ff88;font:16px/1.6 system-ui,Segoe UI,Arial;
    text-align:center;cursor:pointer;letter-spacing:.5px
  }
  #gate .box{border:1px solid #00ff88;padding:18px 22px;border-radius:10px}
</style>
</head>
<body>
<canvas id="out"></canvas>
<video id="v" playsinline muted></video>
<div id="gate"><div class="box">
  CAMERA PERMISSION NEEDED<br/>Click to start
</div></div>

<script>
(function(){
  const v = document.getElementById('v');
  const cnv = document.getElementById('out');
  const g = cnv.getContext('2d', { willReadFrequently:true });
  const gate = document.getElementById('gate');

  // Rendering params (no UI)
  const GRID = 6;          // sampling step in pixels (smaller = denser)
  const MAX_R = 6;         // max dot radius
  const JITTER = 0.25;     // 0..1 jitter inside grid cell
  const TRAIL = 0.15;      // frame fade (higher = longer trails)
  const GREEN = [0, 255, 120]; // matrix-like green
  const CONTRAST = 1.35;   // simple contrast
  const BRIGHT = 0;        // brightness offset

  let running = false, raf = null;

  function resize() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    cnv.width  = Math.floor(innerWidth  * dpr);
    cnv.height = Math.floor(innerHeight * dpr);
    cnv.style.width  = innerWidth + 'px';
    cnv.style.height = innerHeight + 'px';
    g.setTransform(dpr,0,0,dpr,0,0);
  }
  resize(); addEventListener('resize', resize);

  function luma(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

  function loop() {
    if (!running) return;

    // fade previous frame â†’ ghosted trail
    g.fillStyle = `rgba(0,0,0,${TRAIL})`;
    g.fillRect(0,0,cnv.width,cnv.height);

    const vw = v.videoWidth || 640, vh = v.videoHeight || 480;

    // scale video to cover canvas while preserving aspect
    const scale = Math.max(cnv.width / vw, cnv.height / vh);
    const dw = vw * scale, dh = vh * scale;
    const ox = (cnv.width - dw)/2, oy = (cnv.height - dh)/2;

    // draw one frame to an offscreen canvas for pixel sampling
    if (!loop.buf) {
      loop.buf = document.createElement('canvas');
      loop.ctx = loop.buf.getContext('2d', { willReadFrequently:true });
    }
    loop.buf.width = Math.ceil(dw);
    loop.buf.height = Math.ceil(dh);
    loop.ctx.drawImage(v, 0, 0, loop.buf.width, loop.buf.height);

    const step = GRID;
    const img = loop.ctx.getImageData(0,0,loop.buf.width,loop.buf.height).data;

    // additive blend for glow
    const prevOp = g.globalCompositeOperation;
    g.globalCompositeOperation = 'lighter';

    for (let y=0; y<loop.buf.height; y+=step) {
      for (let x=0; x<loop.buf.width; x+=step) {
        const i = ((y*loop.buf.width)+x)*4;
        let r = img[i], gg = img[i+1], b = img[i+2];

        // contrast / brightness
        let L = ((luma(r,gg,b) - 128) * CONTRAST + 128) + BRIGHT;
        if (L<0) L=0; else if (L>255) L=255;

        // map to dot size & alpha
        const radius = 0.5 + (L/255)*MAX_R;
        const alpha  = 0.08 + (L/255)*0.65;

        // jitter inside cell
        const jx = (Math.random()-0.5) * step * JITTER * 2;
        const jy = (Math.random()-0.5) * step * JITTER * 2;

        g.fillStyle = `rgba(${GREEN[0]},${GREEN[1]},${GREEN[2]},${alpha})`;
        g.beginPath();
        g.arc(ox + x + jx, oy + y + jy, radius, 0, Math.PI*2);
        g.fill();
      }
    }

    g.globalCompositeOperation = prevOp;
    raf = requestAnimationFrame(loop);
  }

  async function startCam() {
    if (running) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false });
      v.srcObject = stream;
      await v.play();
      running = true;
      loop();
    } catch (e) {
      // If blocked, show gate; user can click once to allow
      gate.style.display = 'grid';
      console.warn('Camera start failed:', e);
    }
  }

  // Auto-start on load (helps in TouchDesigner Web Render)
  window.addEventListener('load', startCam);

  // Fallback: one tap/click to request again if autoplay/permission blocked
  gate.addEventListener('click', async () => {
    gate.style.display = 'none';
    await startCam();
  });

})();
</script>
</body>
</html>
