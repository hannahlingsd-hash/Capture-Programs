<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Live Point-Cloud Webcam</title>
<style>
  :root { --bg:#0b0c10; --fg:#e6e6e6; --muted:#94a3b8; --border:#1f2937; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,Segoe UI,Arial}
  header{display:flex;gap:14px;align-items:center;flex-wrap:wrap;padding:12px 14px;border-bottom:1px solid var(--border)}
  header label{color:var(--muted);display:flex;align-items:center;gap:8px}
  input[type="range"]{width:130px}
  main{height:calc(100vh - 58px);display:grid;place-items:center;padding:8px}
  canvas{max-width:100%;max-height:100%;background:#000;border:1px solid var(--border);border-radius:12px}
  button{background:#111827;border:1px solid #374151;color:var(--fg);padding:6px 10px;border-radius:8px;cursor:pointer}
  .spacer{flex:1}
</style>
</head>
<body>
<header>
  <button id="start">Start webcam</button>
  <label>Spacing <input id="spacing" type="range" min="2" max="20" value="6"></label>
  <label>Max size <input id="maxsize" type="range" min="1" max="18" value="8"></label>
  <label>Contrast <input id="contrast" type="range" min="0.5" max="3" step="0.05" value="1.4"></label>
  <label>Brightness <input id="brightness" type="range" min="-100" max="100" value="0"></label>
  <label><input id="colorize" type="checkbox" checked> Colorize</label>
  <label>Jitter <input id="jitter" type="range" min="0" max="0.8" step="0.02" value="0.2"></label>
  <div class="spacer"></div>
  <button id="pause">Pause</button>
</header>

<main>
  <canvas id="out"></canvas>
  <video id="v" playsinline muted style="display:none"></video>
  <canvas id="buf" style="display:none"></canvas>
</main>

<script>
(function(){
  const v = document.getElementById('v');
  const c = document.getElementById('out'), g = c.getContext('2d',{willReadFrequently:true});
  const buf = document.getElementById('buf'), gb = buf.getContext('2d',{willReadFrequently:true});

  const startBtn = document.getElementById('start');
  const pauseBtn = document.getElementById('pause');

  const spacing = document.getElementById('spacing');
  const maxsize = document.getElementById('maxsize');
  const contrast = document.getElementById('contrast');
  const brightness = document.getElementById('brightness');
  const colorize = document.getElementById('colorize');
  const jitter = document.getElementById('jitter');

  let running = false;
  let raf = null;

  function resize() {
    const w = v.videoWidth || 640;
    const h = v.videoHeight || 480;
    // draw at native size for sampling; display canvas scales down/up responsively
    buf.width = w; buf.height = h;
    c.width = w; c.height = h;
  }

  function heatColor(l) {
    // l in [0,255] → simple magma-like gradient
    const t = l / 255;
    const r = Math.min(255, Math.floor(255 * Math.pow(t, 0.35)));
    const g = Math.floor(255 * Math.max(0, Math.min(1, (t - 0.25) * 1.4)));
    const b = Math.floor(255 * Math.max(0, 1.1 - 3.2 * t));
    return [r,g,b];
  }

  function loop() {
    if (!running) return;
    // draw frame to buffer
    gb.drawImage(v, 0, 0, buf.width, buf.height);
    const img = gb.getImageData(0, 0, buf.width, buf.height);
    const data = img.data;

    // clear output with slight alpha for soft trailing (optional)
    g.clearRect(0,0,c.width,c.height);

    const S = +spacing.value | 0;
    const MAX = +maxsize.value;
    const K = +contrast.value;
    const B = +brightness.value; // -100..100
    const J = +jitter.value;     // 0..0.8 in “cell units”

    // Render as dots sampled on a grid
    for (let y = 0; y < buf.height; y += S) {
      for (let x = 0; x < buf.width; x += S) {
        const i = ((y * buf.width) + x) * 4;
        // luma
        let r = data[i], gch = data[i+1], b = data[i+2];
        let l = 0.2126*r + 0.7152*gch + 0.0722*b; // 0..255

        // contrast/brightness
        l = ((l - 128) * K + 128) + B;
        if (l < 0) l = 0; else if (l > 255) l = 255;

        // map to size/alpha
        const s = (l / 255) * MAX;     // dot radius
        const alpha = Math.min(1, 0.15 + (l / 255) * 0.85);

        // jitter within the grid cell
        const jx = (Math.random() - 0.5) * S * J * 2;
        const jy = (Math.random() - 0.5) * S * J * 2;

        // color
        let cr, cg, cb;
        if (colorize.checked) {
          [cr,cg,cb] = heatColor(l);
        } else {
          cr = cg = cb = l;
        }

        g.fillStyle = `rgba(${cr|0},${cg|0},${cb|0},${alpha})`;
        g.beginPath();
        g.arc(x + jx, y + jy, Math.max(0.5, s/2), 0, Math.PI*2);
        g.fill();
      }
    }
    raf = requestAnimationFrame(loop);
  }

  async function startCam() {
    if (running) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
      v.srcObject = stream;
      v.onloadedmetadata = () => { resize(); v.play(); running = true; loop(); };
    } catch (e) {
      alert("Camera error: " + e.message + "\nThis must run over HTTPS (GitHub Pages uses HTTPS).");
    }
  }

  startBtn.addEventListener('click', startCam);

  pauseBtn.addEventListener('click', () => {
    if (!v.srcObject) return;
    running = !running;
    pauseBtn.textContent = running ? "Pause" : "Resume";
    if (running) loop(); else cancelAnimationFrame(raf);
  });

  // Auto-start if permissions already granted
  if (location.protocol === 'https:' && navigator.mediaDevices && navigator.permissions) {
    navigator.permissions.query({name: 'camera'}).then(p => {
      if (p.state === 'granted') startCam();
    }).catch(()=>{});
  }

  // Resize canvas if the layout changes (e.g., device rotation)
  window.addEventListener('resize', () => {
    if (v.videoWidth) resize();
  });
})();
</script>
</body>
</html>
