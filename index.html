<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Matrix Particle Dissolve — Webcam</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #out{position:fixed;inset:0;display:block;width:100vw;height:100vh}
  #v{display:none}
  #gate{position:fixed;inset:0;display:none;place-items:center;background:#000a;color:#0f8;
        font:16px system-ui;text-align:center}
  #gate .box{border:1px solid #0f8;padding:16px 20px;border-radius:10px}
  #gate button{margin-top:10px;background:#002d1f;border:1px solid #0f8;color:#0f8;
               padding:6px 10px;border-radius:8px;cursor:pointer}
</style>
</head>
<body>
<canvas id="out"></canvas>
<video id="v" playsinline muted></video>
<div id="gate"><div class="box">
  <div id="msg">Camera permission needed — click “Try again”.</div>
  <button id="retry">Try again</button>
</div></div>

<script>
(function(){
  const v   = document.getElementById('v');
  const cnv = document.getElementById('out');
  const g   = cnv.getContext('2d', { willReadFrequently:true });
  const gate= document.getElementById('gate');
  const msg = document.getElementById('msg');
  const retry=document.getElementById('retry');

  /* ===== knobs (tweak here) ===== */
  const CAP_DPR        = 1;     // 1 = fastest in TouchDesigner
  const SAMPLE_W       = 360;   // downscaled analysis width (240-480)
  const DIFF_THRESHOLD = 18;    // sensitivity to motion/change (lower = more particles)
  const EMIT_PER_HOT   = 6;     // particles to spawn per hot cell
  const MAX_PARTICLES  = 45000; // global cap
  const PARTICLE_SIZE  = [0.6, 2.2]; // min/max radius (px)
  const PARTICLE_LIFE  = [0.6, 2.2]; // seconds
  const GRAVITY        = 12;    // px/s^2 downward (after scale mapping)
  const NOISE_STRENGTH = 40;    // px/s lateral drift
  const FADE_TRAIL     = 0.10;  // canvas fade per frame (0..1) for ghosting
  const GREEN          = [0,255,120]; // matrix color
  /* ============================== */

  // sizing
  function resize(){
    const dpr = Math.min(CAP_DPR, window.devicePixelRatio||1);
    const w = Math.max(1, Math.floor(innerWidth  * dpr));
    const h = Math.max(1, Math.floor(innerHeight * dpr));
    cnv.width = w; cnv.height = h;
    cnv.style.width = innerWidth+'px';
    cnv.style.height= innerHeight+'px';
    g.setTransform(dpr,0,0,dpr,0,0);
  }
  resize(); addEventListener('resize', resize);

  // offscreen analysis buffers
  let ana = document.createElement('canvas');
  let ctx = ana.getContext('2d', { willReadFrequently:true });
  let prev = null;

  // particles
  const P = new Float32Array(MAX_PARTICLES * 7);
  // fields: x,y,vx,vy,life,maxLife,size, stored as:
  // [x,y,vx,vy,life,maxLife,size] per particle
  let pCount = 0;

  function rnd(a,b){ return a + Math.random()*(b-a); }
  function luma(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

  // tiny hash noise (fast, pseudo Perlin-ish)
  function hash(n){ return Math.sin(n*1e-3)*43758.5453 % 1; }
  function noise2(x,y,t){
    const i = Math.floor(x)*374761393 + Math.floor(y)*668265263 + Math.floor(t*60)*700001; // ~frame-based
    return (hash(i)-0.5)*2; // -1..1
  }

  function spawn(x, y, sx, sy, heat){
    const nEmit = Math.min(EMIT_PER_HOT, MAX_PARTICLES - pCount);
    for(let k=0;k<nEmit;k++){
      const idx = pCount * 7;
      // map analysis coords → display (cover)
      const X = sx.originX + x * sx.scaleX;
      const Y = sy.originY + y * sy.scaleY;

      // initial velocity: slight outward burst + random
      const ang = Math.random()*Math.PI*2;
      const spd = 20 + heat * 1.2 + Math.random()*60;
      const vx  = Math.cos(ang)*spd;
      const vy  = Math.sin(ang)*spd - 10;

      P[idx+0]= X;
      P[idx+1]= Y;
      P[idx+2]= vx;
      P[idx+3]= vy;
      P[idx+4]= 0;                      // life
      P[idx+5]= rnd(PARTICLE_LIFE[0], PARTICLE_LIFE[1]); // maxLife (s)
      P[idx+6]= rnd(PARTICLE_SIZE[0], PARTICLE_SIZE[1]); // size (px)
      pCount++;
      if (pCount>=MAX_PARTICLES) break;
    }
  }

  function updateAndRender(dt){
    // ghost the canvas
    g.fillStyle = `rgba(0,0,0,${FADE_TRAIL})`;
    g.fillRect(0,0,cnv.width,cnv.height);

    g.globalCompositeOperation = 'lighter';
    for(let i=0, w=0; i<pCount; ){
      const idx = i*7;
      let x=P[idx], y=P[idx+1], vx=P[idx+2], vy=P[idx+3], life=P[idx+4], maxL=P[idx+5], size=P[idx+6];

      // physics
      // noise drift (frame-based, cheap)
      const t = performance.now()*0.001;
      vx += noise2(x*0.3, y*0.3, t) * NOISE_STRENGTH * dt;
      vy += GRAVITY * dt;

      x += vx * dt;
      y += vy * dt;
      life += dt;

      // out-of-bounds or expired → swap remove
      if (life>=maxL || x<-50 || y<-50 || x>cnv.width+50 || y>cnv.height+50){
        const lastIdx = (pCount-1)*7;
        // swap this with last
        P[idx]=P[lastIdx]; P[idx+1]=P[lastIdx+1]; P[idx+2]=P[lastIdx+2];
        P[idx+3]=P[lastIdx+3]; P[idx+4]=P[lastIdx+4]; P[idx+5]=P[lastIdx+5]; P[idx+6]=P[lastIdx+6];
        pCount--; continue;
      }

      // render
      const a = Math.max(0.02, 1 - life/maxL); // fade out
      g.fillStyle = `rgba(${GREEN[0]},${GREEN[1]},${GREEN[2]},${a*0.9})`;
      g.beginPath();
      g.arc(x, y, size, 0, Math.PI*2);
      g.fill();

      // write back
      P[idx]=x; P[idx+1]=y; P[idx+2]=vx; P[idx+3]=vy; P[idx+4]=life;
      i++; // only advance when we keep the particle
    }
    g.globalCompositeOperation = 'source-over';
  }

  function analysisToDisplay(vw, vh){
    // scale video to cover canvas; compute mapping
    const cover = Math.max(cnv.width/vw, cnv.height/vh);
    const dispW = vw*cover, dispH = vh*cover;
    const ox = (cnv.width - dispW)/2;
    const oy = (cnv.height - dispH)/2;
    return {
      scaleX: dispW / ana.width,
      scaleY: dispH / ana.height,
      originX: ox,
      originY: oy
    };
  }

  let lastT = performance.now();

  function frame(){
    const now = performance.now();
    const dt  = Math.min(0.05, (now - lastT)/1000); // cap dt
    lastT = now;

    if (v.readyState >= 2){
      // set analysis size (respect aspect)
      const vw=v.videoWidth||640, vh=v.videoHeight||480;
      const anaW = SAMPLE_W;
      const anaH = Math.round(anaW * (vh/vw));
      if (ana.width !== anaW || ana.height !== anaH){
        ana.width = anaW; ana.height = anaH;
        prev = null;
      }
      ctx.drawImage(v, 0, 0, ana.width, ana.height);
      const curr = ctx.getImageData(0,0,ana.width,ana.height).data;

      if (prev){
        const map = analysisToDisplay(vw, vh);
        // scan grid; sparse stride for speed
        const STRIDE = 2;
        for(let y=0; y<ana.height; y+=STRIDE){
          for(let x=0; x<ana.width; x+=STRIDE){
            const i = ((y*ana.width)+x)*4;
            const dl = Math.abs(
              (curr[i]*0.2126 + curr[i+1]*0.7152 + curr[i+2]*0.0722) -
              (prev[i]*0.2126 + prev[i+1]*0.7152 + prev[i+2]*0.0722)
            );
            if (dl > DIFF_THRESHOLD){
              // heat scales emission energy a bit
              spawn(x, y, {scaleX:map.scaleX, originX:map.originX},
                         {scaleY:map.scaleY, originY:map.originY}, dl);
            }
          }
        }
      }
      prev = curr;
    }

    updateAndRender(dt);
    requestAnimationFrame(frame);
  }

  async function startCam(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}, audio:false});
      v.srcObject = stream; await v.play();
      resize(); frame();
    }catch(e){
      gate.style.display='grid';
      msg.textContent = 'Camera blocked: ' + e.message;
    }
  }

  window.addEventListener('load', startCam);
  retry.addEventListener('click', ()=>{ gate.style.display='none'; startCam(); });
})();
</script>
</body>
</html>
