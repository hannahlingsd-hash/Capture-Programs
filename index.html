<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Motion Dissolve — Point Cloud (Fast)</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #out{position:fixed;inset:0;width:100vw;height:100vh;display:block;background:#000}
  #v{display:none}
  #gate{position:fixed;inset:0;display:none;place-items:center;background:#000a;color:#0f8;font:16px system-ui}
  #gate .box{border:1px solid #0f8;padding:16px 20px;border-radius:10px}
</style>
</head>
<body>
<canvas id="out"></canvas>
<video id="v" playsinline muted></video>
<div id="gate"><div class="box">Camera permission needed — click to start</div></div>

<script>
(function(){
  const v   = document.getElementById('v');
  const cnv = document.getElementById('out');
  const g   = cnv.getContext('2d', { willReadFrequently:true });
  const gate= document.getElementById('gate');

  /* ---------- knobs (tune here) ---------- */
  const CAP_DPR     = 1;     // keep 1 for TD
  const SAMPLE_W    = 360;   // analysis width (240–480)
  const GRID        = 5;     // grid step (smaller = denser dots)
  const DOT_MIN     = 0.8;   // base dot size (px)
  const DOT_MAX     = 2.0;   // max dot size (px)
  const BASE_ALPHA  = 0.28;  // base dot opacity
  const DIFF_T      = 16;    // motion threshold (lower = more dissolve)
  const DECAY_RATE  = 0.92;  // per-frame decay of dissolve (0.85..0.97)
  const DUST_CHANCE = 0.12;  // chance per hot cell to draw one “dust” speck
  const DUST_ALPHA  = 0.22;  // dust speck opacity
  const GREEN       = [0,255,120]; // matrix green
  /* -------------------------------------- */

  function resize(){
    const dpr = Math.min(CAP_DPR, window.devicePixelRatio||1);
    const w = Math.max(1, Math.floor(innerWidth  * dpr));
    const h = Math.max(1, Math.floor(innerHeight * dpr));
    cnv.width = w; cnv.height = h;
    cnv.style.width = innerWidth + 'px';
    cnv.style.height = innerHeight + 'px';
    g.setTransform(dpr,0,0,dpr,0,0);
  }
  resize(); addEventListener('resize', resize);

  // offscreen analysis
  const ana = document.createElement('canvas');
  const ax  = ana.getContext('2d', { willReadFrequently:true });

  // per-cell state (on the GRID lattice)
  let prevL = null;      // previous luma per cell
  let melt  = null;      // dissolve amount per cell (0..1)

  function luma(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

  function map(vw, vh){
    const cover = Math.max(cnv.width/vw, cnv.height/vh);
    const dispW = vw*cover, dispH = vh*cover;
    const ox = (cnv.width - dispW)/2, oy = (cnv.height - dispH)/2;
    return { ox, oy, sx: dispW/ana.width, sy: dispH/ana.height };
  }

  function frame(){
    requestAnimationFrame(frame);

    if (v.readyState < 2) return;

    const vw = v.videoWidth || 640, vh = v.videoHeight || 480;
    const aw = SAMPLE_W, ah = Math.round(aw * (vh/vw));
    if (ana.width !== aw || ana.height !== ah) {
      ana.width = aw; ana.height = ah;
      prevL = null; melt = null;
    }

    ax.drawImage(v, 0, 0, aw, ah);
    const img = ax.getImageData(0, 0, aw, ah).data;

    // initialize per-cell buffers
    const gw = Math.floor(aw / GRID);
    const gh = Math.floor(ah / GRID);
    if (!prevL || prevL.length !== gw*gh) {
      prevL = new Float32Array(gw*gh);
      melt  = new Float32Array(gw*gh);
      prevL.fill(0); melt.fill(0);
    }

    const M = map(vw, vh);

    // fade the whole canvas slightly for a soft temporal blend
    g.fillStyle = 'rgba(0,0,0,0.08)';
    g.fillRect(0,0,cnv.width,cnv.height);

    // draw base cloud and update dissolve
    // (use squares via fillRect — cheaper than arcs)
    for (let gy = 0, j = 0; gy < gh; gy++) {
      const y = gy*GRID;
      for (let gx = 0; gx < gw; gx++, j++) {
        const x = gx*GRID;
        const i = ((y*aw)+x) * 4;
        const L = luma(img[i], img[i+1], img[i+2]); // 0..255

        // motion → increase melt; otherwise decay toward 0
        const dl = Math.abs(L - prevL[j]);
        prevL[j] = L;
        if (dl > DIFF_T) {
          melt[j] = 1; // “just melted”
        } else {
          melt[j] *= DECAY_RATE;
        }

        // dot size/alpha from brightness, reduced by melt
        const size = DOT_MIN + (L/255) * (DOT_MAX - DOT_MIN);
        const alpha = BASE_ALPHA * (L/255) * (1 - melt[j]);

        // map to display coords
        const dx = M.ox + x * M.sx;
        const dy = M.oy + y * M.sy;

        if (alpha > 0.004) {
          g.fillStyle = `rgba(${GREEN[0]},${GREEN[1]},${GREEN[2]},${alpha})`;
          // scale dot size by display scale so it looks consistent
          g.fillRect(dx, dy, size * M.sx, size * M.sy);
        }

        // sparse dust specks inside melting cells (point-like, no velocity)
        if (melt[j] > 0.4 && Math.random() < DUST_CHANCE) {
          const rx = dx + (Math.random() - 0.5) * GRID * M.sx;
          const ry = dy + (Math.random() - 0.5) * GRID * M.sy;
          g.fillStyle = `rgba(${GREEN[0]},${GREEN[1]},${GREEN[2]},${DUST_ALPHA * melt[j]})`;
          g.fillRect(rx, ry, 1, 1);
        }
      }
    }
  }

  async function startCam(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false });
      v.srcObject = stream; await v.play(); frame();
    }catch(e){
      gate.style.display='grid';
      console.warn('Camera error:', e);
    }
  }
  window.addEventListener('load', startCam);
  gate.addEventListener('click', ()=>{ gate.style.display='none'; startCam(); });
})();
</script>
</body>
</html>
