<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Wind-on-Wall — WebRender Fill (TD-safe, mint stain)</title>
<style>
  html,body{height:100%;margin:0;background:#000}
  .root{position:fixed;inset:0;background:#000}
  canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:fill;background:#000}
  /* --- minimal UI --- */
  .ui{position:fixed;left:12px;top:12px;z-index:10;
      font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:#ddd;background:rgba(0,0,0,.45);backdrop-filter:blur(4px);
      border:1px solid rgba(255,255,255,.1);border-radius:8px;padding:8px 10px;max-width:260px}
  .ui label{display:flex;align-items:center;gap:8px;margin:6px 0}
  .ui input[type="range"]{width:140px}
  .ui .row{display:flex;justify-content:space-between;align-items:center;gap:10px}
  .ui .val{min-width:46px;text-align:right;color:#9ad}
  .ui button{all:unset;background:#1b1f24;color:#cfe;padding:4px 8px;border-radius:6px;border:1px solid #2a3340;cursor:pointer}
  .ui button:active{transform:translateY(1px)}
</style>
</head>
<body>
  <div class="root">
    <canvas id="view"></canvas>
    <canvas id="stain"></canvas>
  </div>

  <!-- Minimal control panel -->
  <div class="ui" id="ui">
    <label><input type="checkbox" id="recallOn"> Random recall</label>
    <div class="row">
      <span>Recall prob</span>
      <input type="range" id="recallProb" min="0" max="0.05" step="0.001">
      <span class="val" id="recallProbVal"></span>
    </div>
    <div class="row">
      <span>Recall opacity</span>
      <input type="range" id="recallAlpha" min="0" max="0.6" step="0.01">
      <span class="val" id="recallAlphaVal"></span>
    </div>
    <div class="row">
      <button id="recallOnce">Recall now</button>
      <span style="opacity:.7">force one reappearance</span>
    </div>
  </div>

<script>
/* Fixed params (mint tint on stain) */
const PARAMS = {
  dt: 2.5,
  thr: 60,
  blur: 0,
  grey: 60,
  stainOn: true,
  decay: 0.935,
  strength: 0.8,     // stronger color presence
  color: "#A6D0FF",  // soft blue

  /* temporal cross-mapping (random remembering) */
  recallOn: true,          // toggle random recall of past stains
  recallProb: 0.012,       // per-frame probability of a recall
  recallAlpha: 0.14,       // opacity of recalled stain
  recallIntervalSec: 1.5,  // snapshot cadence
  recallMax: 24            // snapshot buffer size
};

(async function(){
  const view = document.getElementById('view');
  const vctx = view.getContext('2d');
  const stain = document.getElementById('stain');
  const sctx = stain.getContext('2d');

  // Offscreens
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', { willReadFrequently: true });
  const maskCanvas = document.createElement('canvas');
  const maskCtx = maskCanvas.getContext('2d');

  // Size to device pixels
  function fit(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = view.getBoundingClientRect();
    const w = Math.max(2, Math.round(rect.width  * dpr));
    const h = Math.max(2, Math.round(rect.height * dpr));
    [view, stain, proc, maskCanvas].forEach(c => { c.width = w; c.height = h; });
  }
  new ResizeObserver(fit).observe(document.body);
  fit();

  // Video source: autostart webcam (https or http://localhost required)
  const vid = document.createElement('video');
  vid.playsInline = true; vid.muted = true; vid.autoplay = true;

  let mediaStream = null;
  async function startWebcam(){
    try{
      stopWebcam();
      mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      vid.srcObject = mediaStream;
      await vid.play();
    }catch(e){
      const qs = new URLSearchParams(location.search);
      const src = qs.get('src');
      if(src){ vid.src = src; vid.play().catch(()=>{}); }
    }
  }
  function stopWebcam(){
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  }

  // Draw current video frame scaled to FILL the canvas
  function drawFit(ctx, video, W, H, blurPx){
    ctx.save();
    ctx.clearRect(0,0,W,H);
    if(blurPx>0) ctx.filter = `blur(${blurPx}px)`;
    const vw = video.videoWidth || 0, vh = video.videoHeight || 0;
    if(vw && vh){
      const s = Math.max(W/vw, H/vh); // cover
      const dw = Math.round(vw*s), dh = Math.round(vh*s);
      const dx = Math.floor((W - dw)/2), dy = Math.floor((H - dh)/2);
      ctx.drawImage(video, dx, dy, dw, dh);
    }
    ctx.restore();
  }

  // Timebase that works in TD even when video.currentTime is NaN for MediaStream
  function nowSec(){
    const t = vid.currentTime;
    return (t && isFinite(t)) ? t : performance.now()/1000;
  }

  // Ring buffer of past frames
  const buf = []; const MAX_SEC = 14;
  function pushFrame(imgData, t){
    buf.push({ t, data: new Uint8ClampedArray(imgData.data), w: imgData.width, h: imgData.height });
    const cutoff = t - (MAX_SEC + 2);
    while(buf.length && buf[0].t < cutoff) buf.shift();
  }
  function getPastFrame(delta){
    const target = nowSec() - delta;
    for(let i=buf.length-1;i>=0;i--) if(buf[i].t <= target) return buf[i];
    return buf[0] || null;
  }

  /* snapshot bank of the stain layer for non-deterministic recall */
  const recallBank = [];
  let lastSnapT = 0;
  function maybeSnapshotStain(W,H, t){
    if(!PARAMS.recallOn) return;
    if(t - lastSnapT < PARAMS.recallIntervalSec) return;
    lastSnapT = t;
    const c = document.createElement('canvas');
    c.width = W; c.height = H;
    c.getContext('2d').drawImage(stain, 0, 0);
    recallBank.push(c);
    if(recallBank.length > PARAMS.recallMax) recallBank.shift();
  }
  function recallStainOnce(W,H, alpha = PARAMS.recallAlpha){
    if(recallBank.length === 0) return;
    const idx = (Math.random()*recallBank.length)|0;
    const snap = recallBank[idx];
    sctx.save();
    sctx.globalAlpha = alpha;
    sctx.globalCompositeOperation = 'source-over';
    sctx.drawImage(snap, 0, 0, W, H);
    sctx.restore();
  }
  function maybeRecallStain(W,H){
    if(!PARAMS.recallOn) return;
    if(Math.random() > PARAMS.recallProb) return;
    recallStainOnce(W,H);
  }

  // Minimal UI wiring
  const ui = {
    recallOn: document.getElementById('recallOn'),
    recallProb: document.getElementById('recallProb'),
    recallProbVal: document.getElementById('recallProbVal'),
    recallAlpha: document.getElementById('recallAlpha'),
    recallAlphaVal: document.getElementById('recallAlphaVal'),
    recallOnce: document.getElementById('recallOnce')
  };
  // initialize values
  ui.recallOn.checked = PARAMS.recallOn;
  ui.recallProb.value = PARAMS.recallProb;
  ui.recallAlpha.value = PARAMS.recallAlpha;
  ui.recallProbVal.textContent = PARAMS.recallProb.toFixed(3);
  ui.recallAlphaVal.textContent = PARAMS.recallAlpha.toFixed(2);
  // listeners
  ui.recallOn.addEventListener('change', e => PARAMS.recallOn = e.target.checked);
  ui.recallProb.addEventListener('input', e => {
    PARAMS.recallProb = parseFloat(e.target.value);
    ui.recallProbVal.textContent = PARAMS.recallProb.toFixed(3);
  });
  ui.recallAlpha.addEventListener('input', e => {
    PARAMS.recallAlpha = parseFloat(e.target.value);
    ui.recallAlphaVal.textContent = PARAMS.recallAlpha.toFixed(2);
  });
  ui.recallOnce.addEventListener('click', () => recallStainOnce(view.width, view.height, PARAMS.recallAlpha));

  // Render loop
  function tick(){
    requestAnimationFrame(tick);
    if(!(vid.videoWidth && vid.videoHeight)) return;

    const W = view.width, H = view.height;

    // Current frame
    drawFit(pctx, vid, W, H, PARAMS.blur);
    const curr = pctx.getImageData(0,0,W,H);
    pushFrame(curr, nowSec());

    const past = getPastFrame(PARAMS.dt);
    if(!past) return;

    // Diff + composite
    const c = curr.data, p = past.data;
    const out = vctx.createImageData(W,H);
    const od  = out.data;
    const md  = new Uint8ClampedArray(W*H);
    const thr = PARAMS.thr, grey = PARAMS.grey;

    for(let i=0, j=0; i<c.length; i+=4, j++){
      const r=c[i], g=c[i+1], b=c[i+2];
      const pr=p[i], pg=p[i+1], pb=p[i+2];
      const lc = r*0.2126 + g*0.7152 + b*0.0722;
      const lp = pr*0.2126 + pg*0.7152 + pb*0.0722;
      const d = Math.abs(lc - lp);

      if(d > thr){
        md[j]=255;
        od[i]   = (r + (255 - pr)) * 0.5;
        od[i+1] = (g + (255 - pg)) * 0.5;
        od[i+2] = (b + (255 - pb)) * 0.5;
        od[i+3] = 255;
      } else {
        md[j]=0;
        od[i]=od[i+1]=od[i+2]=grey; od[i+3]=255;
      }
    }
    vctx.putImageData(out, 0, 0);

    // Residual staining
    if(PARAMS.stainOn){
      sctx.globalCompositeOperation = 'destination-out';
      sctx.fillStyle = `rgba(0,0,0,${1 - PARAMS.decay})`;
      sctx.fillRect(0,0,W,H);
      sctx.globalCompositeOperation = 'source-over';

      const mImg = maskCtx.createImageData(W,H);
      const mdat = mImg.data;
      for(let j=0, k=0; j<md.length; j++, k+=4){
        const v = md[j];
        mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v;
      }
      maskCtx.putImageData(mImg, 0, 0);

      maskCtx.globalCompositeOperation = 'source-in';
      maskCtx.fillStyle = PARAMS.color;        // ← mint tint
      maskCtx.globalAlpha = PARAMS.strength;
      maskCtx.fillRect(0,0,W,H);
      maskCtx.globalAlpha = 1;
      maskCtx.globalCompositeOperation = 'source-over';

      sctx.drawImage(maskCanvas, 0, 0);

      // remember & maybe recall
      maybeSnapshotStain(W,H, nowSec());
      maybeRecallStain(W,H);
    }

    // Composite stain over view
    if(PARAMS.stainOn){
      vctx.globalCompositeOperation = 'multiply';
      vctx.drawImage(stain, 0, 0);
      vctx.globalCompositeOperation = 'source-over';
    }
  }

  requestAnimationFrame(tick);
  startWebcam();
  window.addEventListener('beforeunload', stopWebcam);
})();
</script>
</body>
</html>
