<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Edge Dissolve + Luma Underpaint</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #out{position:fixed;inset:0;display:block;width:100vw;height:100vh}
  #v{display:none}
  #gate{position:fixed;inset:0;display:none;place-items:center;background:#000a;color:#0f8;font:16px system-ui}
  #gate .box{border:1px solid #0f8;padding:10px 14px;border-radius:10px}
  #hud{position:fixed;left:12px;bottom:12px;color:#bff;background:#0008;padding:8px 10px;border:1px solid #395;border-radius:10px;font:12px ui-monospace,system-ui}
  #hud b{color:#eff}
</style>
</head>
<body>
<canvas id="out"></canvas>
<video id="v" playsinline muted></video>
<div id="gate"><div class="box">Click to allow camera</div></div>
<div id="hud"></div>

<script>
(function(){
  const v = document.getElementById('v');
  const cnv = document.getElementById('out');
  const g = cnv.getContext('2d', { willReadFrequently:true });
  const hud = document.getElementById('hud');
  const gate = document.getElementById('gate');

  /* ---------------- core knobs ---------------- */
  const MAX_SAMPLE_W = 720;
  let   GRID = 3;                 // edge sampling step
  let   DOT  = 1.1;               // particle dot size
  const EDGE_T = 46;
  const CONTRAST_EXP = 1.2;
  const TRAIL  = 0.30;            // frame fade
  let   LIFE_STEP = 0.040;
  const V_DAMP = 0.92;
  let   ADD_GAIN = 0.34;          // particle brightness
  const TINT = [160,255,210];
  const CAP_DPR = 1;

  // Motion, sustain, contour
  let MOTION_BIAS_ON = true, MOTION_GAIN = 3.2, MOTION_DECAY = 0.88;
  let SUSTAIN_ON = true, SUSTAIN_GAIN = 0.030;
  let EDGE_THICKNESS = 2;         // 1..3
  /* ------------------------------------------- */

  /* ---------- Luma underpaint (new) ---------- */
  let UNDERPAINT_ON = true;
  let UP_GAIN = 0.40;             // additive highlight mix (0..1)
  let SH_GAIN = 0.20;             // shadow multiply mix (0..1)
  const UP_GRID = 2;              // micro-dot step in analysis space (small = denser)
  const UP_GAMMA = 1.15;          // luma curve; >1 = more contrast
  /* ------------------------------------------- */

  // pooled particles
  const MAX_PARTICLES = 90000;
  const px=new Float32Array(MAX_PARTICLES), py=new Float32Array(MAX_PARTICLES);
  const vx=new Float32Array(MAX_PARTICLES), vy=new Float32Array(MAX_PARTICLES);
  const life=new Float32Array(MAX_PARTICLES), size=new Float32Array(MAX_PARTICLES);
  let head=0;

  function spawn(x,y,nx,ny,mag){
    const i=head; head=(head+1)%MAX_PARTICLES;
    px[i]=x; py[i]=y;
    const spd = Math.min(1, mag/220)*0.5;
    vx[i]=nx*spd; vy[i]=ny*spd;
    life[i]=1.0;
    size[i]=DOT*(0.85+Math.random()*0.35);
  }

  // low-res flow field
  let FW=0,FH=0,fieldX=null,fieldY=null,fieldNext=0;
  function ensureField(w,h){
    const cell = 36;
    FW = Math.max(16, Math.round(w/cell));
    FH = Math.max(12, Math.round(h/cell));
    fieldX = new Float32Array(FW*FH);
    fieldY = new Float32Array(FW*FH);
  }
  function updateField(t){
    if (t < fieldNext) return;
    fieldNext = t + 0.12;
    const ax=0.4, ay=0.4, fx=0.8, fy=0.6;
    for (let j=0;j<FH;j++){
      for (let i=0;i<FW;i++){
        const u=i/FW, v=j/FH;
        const dx=Math.sin((u*fx + t*0.16)*6.283)*ax;
        const dy=Math.cos((v*fy - t*0.13)*6.283)*ay;
        const len=Math.hypot(dx,dy)||1;
        fieldX[j*FW+i]=dx/len*0.22;
        fieldY[j*FW+i]=dy/len*0.22;
      }
    }
  }
  function sampleField(x,y){
    const ci = Math.max(0, Math.min(FW-1, (x/cnv.width*FW)|0));
    const cj = Math.max(0, Math.min(FH-1, (y/cnv.height*FH)|0));
    const k=cj*FW+ci;
    return [fieldX[k], fieldY[k]];
  }

  // sizing
  function resize(){
    const dpr=Math.min(CAP_DPR, window.devicePixelRatio||1);
    const w=Math.max(1, Math.floor(innerWidth*dpr));
    const h=Math.max(1, Math.floor(innerHeight*dpr));
    cnv.width=w; cnv.height=h;
    cnv.style.width=innerWidth+'px';
    cnv.style.height=innerHeight+'px';
    g.setTransform(dpr,0,0,dpr,0,0);
    ensureField(w,h);
  }
  resize(); addEventListener('resize', resize);

  // analysis buffers
  let buf=document.createElement('canvas');
  let gb =buf.getContext('2d', { willReadFrequently:true });
  function luma(r,g,b){ return 0.2126*r+0.7152*g+0.0722*b; }
  let prevY=null, motionEMA=null, mW=0, mH=0;

  // HUD
  let fps=60,last=performance.now(),showHUD=true, SPAWN_MULT=1.0, autoT=true;
  function drawHUD(){
    if(!showHUD){ hud.style.display='none'; return; }
    hud.style.display='block';
    hud.innerHTML = `<b>Edge + Underpaint</b> • ${fps.toFixed(0)} fps<br>
    GRID ${GRID}px • DOT ${DOT.toFixed(2)} • Spawn ${SPAWN_MULT.toFixed(2)} • Bright ${ADD_GAIN.toFixed(2)} • MotGain ${MOTION_GAIN.toFixed(2)} • EdgeThick ${EDGE_THICKNESS}<br>
    Underpaint ${UNDERPAINT_ON?'ON':'OFF'} (U/J ${UP_GAIN.toFixed(2)}) • Shadow ${SH_GAIN.toFixed(2)} • SUSTAIN ${SUSTAIN_ON?'ON':'OFF'} (${SUSTAIN_GAIN.toFixed(3)}) • ${autoT?'Auto':'Manual'}<br>
    [/]=grid  -/==dot  ;/'=spawn  B/N=brightness  Y/H=shadow±  K=underpaint  S=toggle sustain ,/.=sustain±  G/H=motion gain±  T=thickness  F=auto  C=clear  Shift+H=HUD`;
  }

  function loop(){
    const now=performance.now();
    const dt=Math.min(50, now-last); last=now;
    fps = 1000/Math.max(1,dt);

    g.fillStyle=`rgba(0,0,0,${TRAIL})`;
    g.fillRect(0,0,cnv.width,cnv.height);

    updateField(now*0.001);

    const vw=v.videoWidth||640, vh=v.videoHeight||480;
    const coverScale=Math.max(cnv.width/vw, cnv.height/vh);
    const drawW=Math.min(MAX_SAMPLE_W, Math.ceil(vw*coverScale));
    const drawH=Math.ceil(drawW*(vh/vw));
    if (!motionEMA || mW!==drawW || mH!==drawH){
      motionEMA = new Float32Array(drawW*drawH);
      mW=drawW; mH=drawH;
    }
    buf.width=drawW; buf.height=drawH;
    gb.drawImage(v,0,0,drawW,drawH);
    const img=gb.getImageData(0,0,drawW,drawH).data;

    const dispW=vw*coverScale, dispH=vh*coverScale;
    const ox=(cnv.width-dispW)/2, oy=(cnv.height-dispH)/2;
    const sx=dispW/drawW, sy=dispH/drawH;

    // luma + motion (EMA)
    const Y=new Float32Array(drawW*drawH);
    for(let y=0,i=0,p=0;y<drawH;y++){
      for(let x=0;x<drawW;x++,i++,p+=4){
        const L=luma(img[p],img[p+1],img[p+2]);
        Y[i]=L;
        const prev = prevY?prevY[i]:L;
        const d = Math.abs(L - prev);
        motionEMA[i] = motionEMA[i]*MOTION_DECAY + d*(1-MOTION_DECAY);
      }
    }
    prevY = Y;

    // FPS-aware budget
    let budget = 17000;
    if (autoT){
      if (fps<48) budget*=0.7;
      else if (fps>56) budget*=1.15;
    }

    // Sobel edges with motion boost
    const Gx=[-1,0,1,-2,0,2,-1,0,1], Gy=[-1,-2,-1,0,0,0,1,2,1];
    for(let y=1;y<drawH-1;y+=GRID){
      const row=y*drawW;
      for(let x=1;x<drawW-1;x+=GRID){
        let sxv=0, syv=0, k=0;
        for(let j=-1;j<=1;j++){
          const r=row+j*drawW;
          for(let i=-1;i<=1;i++,k++){
            const val=Y[r+x+i];
            sxv+=Gx[k]*val; syv+=Gy[k]*val;
          }
        }
        let mag=Math.hypot(sxv,syv);
        if(mag<EDGE_T) continue;

        // contrast curve
        mag = Math.pow((mag-EDGE_T)/255, CONTRAST_EXP)*255;

        // motion-edge boost
        let boost = 1;
        if (MOTION_BIAS_ON){
          const mot = motionEMA[row+x]/128;
          boost += MOTION_GAIN*Math.min(1, mot);
        }
        const len = Math.max(1e-6, Math.hypot(sxv,syv));
        const nx=sxv/len, ny=syv/len;

        // spawn probability
        let prob = Math.min(1, mag*0.010*boost*SPAWN_MULT);
        if (Math.random()<prob && --budget>0){
          const cx=ox+x*sx, cy=oy+y*sy;
          spawn(
            cx + (Math.random()-0.5)*sx*GRID*0.22,
            cy + (Math.random()-0.5)*sy*GRID*0.22,
            nx, ny, mag*boost
          );

          // contour reinforcement along ±n̂
          if (boost>1.2 && EDGE_THICKNESS>1){
            const step = Math.max(sx, sy)*0.6;
            g.globalCompositeOperation='lighter';
            g.fillStyle=`rgba(${TINT[0]},${TINT[1]},${TINT[2]},${ADD_GAIN*0.55})`;
            for (let t=1; t<EDGE_THICKNESS; t++){
              const off = step*t;
              g.fillRect(cx + nx*off, cy + ny*off, DOT, DOT);
              g.fillRect(cx - nx*off, cy - ny*off, DOT, DOT);
            }
            g.globalCompositeOperation='source-over';
          }
        }
        if (budget<=0) break;
      }
      if (budget<=0) break;
    }

    /* --------- Luma underpaint (highlights & shadows) --------- */
    if (UNDERPAINT_ON){
      const inv255 = 1/255;
      const step = Math.max(1, UP_GRID); // analysis grid step
      // Highlights (additive)
      g.globalCompositeOperation='lighter';
      g.fillStyle=`rgba(${TINT[0]},${TINT[1]},${TINT[2]},${UP_GAIN})`;
      for (let y=0; y<drawH; y+=step){
        const row = y*drawW;
        for (let x=0; x<drawW; x+=step){
          let L = Y[row+x]*inv255;
          L = Math.pow(L, UP_GAMMA);
          if (L < 0.25) continue; // keep it light
          const a = (L-0.25)*1.333*UP_GAIN; // remap 0.25..1 → 0..1
          if (a<=0) continue;
          g.globalAlpha = a;
          g.fillRect(ox + x*sx, oy + y*sy, DOT*0.9, DOT*0.9);
        }
      }
      // Shadows (multiply) — very light to suggest volume
      if (SH_GAIN>0.001){
        g.globalCompositeOperation='multiply';
        // teal-ish dark so it stays in palette
        g.fillStyle=`rgba(24,64,54,${SH_GAIN})`;
        for (let y=0; y<drawH; y+=step){
          const row = y*drawW;
          for (let x=0; x<drawW; x+=step){
            const L = Y[row+x]*inv255;
            const d = (0.45 - L);     // below mid-gray darkens
            if (d <= 0) continue;
            g.globalAlpha = Math.min(0.6, d*1.6*SH_GAIN);
            g.fillRect(ox + x*sx, oy + y*sy, DOT, DOT);
          }
        }
      }
      g.globalAlpha=1;
      g.globalCompositeOperation='source-over';
    }
    /* ----------------------------------------------------------- */

    // draw particles (with sustain)
    g.globalCompositeOperation='lighter';
    g.fillStyle = `rgba(${TINT[0]},${TINT[1]},${TINT[2]},${ADD_GAIN})`;
    for(let i=0;i<MAX_PARTICLES;i++){
      if(life[i]<=0) continue;
      const f=sampleField(px[i],py[i]);
      vx[i]+=f[0]; vy[i]+=f[1];
      px[i]+=vx[i]; py[i]+=vy[i];
      vx[i]*=V_DAMP; vy[i]*=V_DAMP;

      if (SUSTAIN_ON){
        const mx = Math.max(0, Math.min(drawW-1, ((px[i]-ox)/sx)|0));
        const my = Math.max(0, Math.min(drawH-1, ((py[i]-oy)/sy)|0));
        const mVal = motionEMA[my*drawW + mx] || 0;
        const sustain = (mVal/255) * SUSTAIN_GAIN;
        life[i] = Math.min(1, life[i] - LIFE_STEP + sustain);
      } else {
        life[i] -= LIFE_STEP;
      }
      if(life[i]<=0){ life[i]=0; continue; }

      const s=size[i]*(0.70+0.30*life[i]);
      g.fillRect(px[i],py[i],s,s);
    }
    g.globalCompositeOperation='source-over';

    drawHUD();
    requestAnimationFrame(loop);
  }

  // camera + controls
  async function startCam(){
    try{
      const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'},audio:false});
      v.srcObject=stream; await v.play(); loop();
    }catch(e){ gate.style.display='grid'; console.warn(e); }
  }
  window.addEventListener('load', startCam);
  gate.addEventListener('click', ()=>{ gate.style.display='none'; startCam(); });

  addEventListener('keydown',(e)=>{
    if(e.key==='[') GRID = Math.min(10, GRID+1);
    else if(e.key===']') GRID = Math.max(2, GRID-1);
    else if(e.key==='-') DOT = Math.max(0.6, DOT-0.1);
    else if(e.key==='=') DOT = Math.min(2.2, DOT+0.1);
    else if(e.key===';') SPAWN_MULT = Math.max(0.3, SPAWN_MULT*0.9);
    else if(e.key==="'") SPAWN_MULT = Math.min(3.0, SPAWN_MULT*1.1);
    else if(e.key==='b'||e.key==='B') ADD_GAIN = Math.min(0.6, ADD_GAIN+0.02);
    else if(e.key==='n'||e.key==='N') ADD_GAIN = Math.max(0.10, ADD_GAIN-0.02);
    else if(e.key==='g') MOTION_GAIN = Math.max(0.0, MOTION_GAIN-0.2);
    else if(e.key==='h') MOTION_GAIN = Math.min(6.0, MOTION_GAIN+0.2);
    else if(e.key==='t'||e.key==='T'){ EDGE_THICKNESS = EDGE_THICKNESS%3 + 1; }
    else if(e.key==='m'||e.key==='M') MOTION_BIAS_ON = !MOTION_BIAS_ON;
    else if(e.key==='s'||e.key==='S') SUSTAIN_ON = !SUSTAIN_ON;
    else if(e.key===',' ) SUSTAIN_GAIN = Math.max(0.0, SUSTAIN_GAIN-0.005);
    else if(e.key==='.' ) SUSTAIN_GAIN = Math.min(0.06, SUSTAIN_GAIN+0.005);
    else if(e.key==='u'||e.key==='U') UP_GAIN = Math.min(1.0, UP_GAIN+0.05);
    else if(e.key==='j'||e.key==='J') UP_GAIN = Math.max(0.0, UP_GAIN-0.05);
    else if(e.key==='y'||e.key==='Y') SH_GAIN = Math.min(0.8, SH_GAIN+0.05);
    else if(e.key==='H') SH_GAIN = Math.max(0.0, SH_GAIN-0.05);
    else if(e.key==='k'||e.key==='K') UNDERPAINT_ON = !UNDERPAINT_ON;
    else if(e.key==='f'||e.key==='F') autoT=!autoT;
    else if(e.key==='c'||e.key==='C'){ for(let i=0;i<MAX_PARTICLES;i++) life[i]=0; }
    else if(e.key==='?'){ console.log({GRID, DOT, SPAWN_MULT, ADD_GAIN, UP_GAIN, SH_GAIN, MOTION_GAIN, EDGE_THICKNESS}); }
    drawHUD();
  });

  drawHUD();
})();
</script>
</body>
</html>
