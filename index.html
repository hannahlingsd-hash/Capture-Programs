<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Matrix Point-Cloud (Webcam) — Ghosty</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #out{position:fixed;inset:0;display:block;width:100vw;height:100vh}
  #v{display:none}
  #gate{position:fixed;inset:0;display:none;place-items:center;background:#000a;color:#0f8;font:16px system-ui}
  #gate .box{border:1px solid #0f8;padding:16px 20px;border-radius:10px}
</style>
</head>
<body>
<canvas id="out"></canvas>
<video id="v" playsinline muted></video>
<div id="gate"><div class="box">Camera permission needed — click to start</div></div>

<script>
(function(){
  const v = document.getElementById('v');
  const cnv = document.getElementById('out');
  const g = cnv.getContext('2d', { willReadFrequently:true });
  const gate = document.getElementById('gate');

  /* -------- tuned for smaller, ghostier dots -------- */
  const MAX_SAMPLE_W = 520;   // 480–600 = detail/speed tradeoff
  const GRID = 4;             // denser grid (3 = ultra dense, heavier)
  const MAX_R = 1.6;          // much smaller dots
  const JITTER = 0.65;        // break the grid feel inside each cell
  const TRAIL = 0.08;         // lower = longer persistence (ghostier)
  const CONTRAST = 1.18;      // gentle contrast
  const BRIGHT = 0;           // overall offset
  const GAMMA = 0.85;         // <1 brightens shadows a bit, keeps figure
  const BASE_A = 0.02;        // base alpha
  const SCALE_A = 0.28;       // alpha gain with brightness
  const GREEN = [0,255,120];  // matrix green
  const CAP_DPR = 1;          // TD: keep 1 for speed
  /* -------------------------------------------------- */

  let running = false;

  function luma(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

  function resize() {
    const dpr = Math.min(CAP_DPR, window.devicePixelRatio || 1);
    const w = Math.max(1, Math.floor(innerWidth  * dpr));
    const h = Math.max(1, Math.floor(innerHeight * dpr));
    cnv.width = w; cnv.height = h;
    cnv.style.width = innerWidth + 'px';
    cnv.style.height = innerHeight + 'px';
    g.setTransform(dpr,0,0,dpr,0,0);
  }
  resize(); addEventListener('resize', resize);

  // offscreen buffer for cheap sampling
  const buf = document.createElement('canvas');
  const gb  = buf.getContext('2d', { willReadFrequently:true });

  let tFrame = 0;

  function loop() {
    if (!running) return;

    // subtle persistence / ghosting
    g.fillStyle = `rgba(0,0,0,${TRAIL})`;
    g.fillRect(0,0,cnv.width,cnv.height);

    const vw = v.videoWidth || 640, vh = v.videoHeight || 480;

    // draw into a downscaled buffer and sample from there
    const coverScale = Math.max(cnv.width / vw, cnv.height / vh);
    const drawW = Math.min(MAX_SAMPLE_W, Math.ceil(vw * coverScale));
    const drawH = Math.ceil(drawW * (vh / vw));

    buf.width = drawW;
    buf.height = drawH;
    gb.drawImage(v, 0, 0, drawW, drawH);

    const img = gb.getImageData(0, 0, drawW, drawH).data;

    // map sampled grid to display
    const dispW = vw * coverScale;
    const dispH = vh * coverScale;
    const ox = (cnv.width - dispW)/2, oy = (cnv.height - dispH)/2;
    const sx = dispW / drawW, sy = dispH / drawH;

    const prevOp = g.globalCompositeOperation;
    g.globalCompositeOperation = 'lighter';

    // deterministic tiny jitter (less “TV static” than Math.random per sample)
    const seed = tFrame * 0.6180339887; // golden ratio step
    function jhash(x,y){
      // quick hash → [-0.5, 0.5]
      const s = Math.sin((x*374761393 ^ y*668265263) + seed) * 43758.5453;
      return (s - Math.floor(s)) - 0.5;
    }

    for (let y = 0; y < drawH; y += GRID) {
      for (let x = 0; x < drawW; x += GRID) {
        const i = ((y * drawW) + x) * 4;
        const r = img[i], gg = img[i+1], b = img[i+2];

        // tone-map luminance (gamma + contrast)
        let L = ((luma(r,gg,b) - 128) * CONTRAST + 128) + BRIGHT;
        if (L < 0) L = 0; else if (L > 255) L = 255;
        const t = Math.pow(L/255, GAMMA);   // 0..1

        // tiny dots + ghosty alpha
        const radius = 0.25 + t * MAX_R;
        const alpha  = BASE_A + t * SCALE_A;

        // jitter within the cell (break the grid)
        const jx = jhash(x,y) * GRID * JITTER * sx;
        const jy = jhash(y,x) * GRID * JITTER * sy;

        g.fillStyle = `rgba(${GREEN[0]},${GREEN[1]},${GREEN[2]},${alpha})`;
        g.beginPath();
        g.arc(ox + x * sx + jx, oy + y * sy + jy, radius, 0, Math.PI*2);
        g.fill();
      }
    }
    g.globalCompositeOperation = prevOp;

    tFrame++;
    requestAnimationFrame(loop);
  }

  async function startCam() {
    if (running) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false });
      v.srcObject = stream;
      await v.play();
      running = true; loop();
    } catch (e) {
      gate.style.display = 'grid'; // click-to-start fallback
      console.warn('Camera start failed:', e);
    }
  }

  window.addEventListener('load', startCam);
  gate.addEventListener('click', async () => { gate.style.display='none'; await startCam(); });
})();
</script>
</body>
</html>
