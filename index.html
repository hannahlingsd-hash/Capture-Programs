<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Alt Point-Cloud Modes — Edge / Flow / LumaDepth</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #out{position:fixed;inset:0;display:block;width:100vw;height:100vh}
  #v{display:none}
  #gate{position:fixed;inset:0;display:none;place-items:center;background:#000a;color:#0f8;font:16px system-ui}
  #gate .box{border:1px solid #0f8;padding:16px 20px;border-radius:10px}
  #hud{position:fixed;left:12px;bottom:12px;color:#9ef;background:#0008;padding:10px 12px;border:1px solid #395;border-radius:10px;font:12px ui-monospace,system-ui}
  #hud b{color:#cfe}
</style>
</head>
<body>
<canvas id="out"></canvas>
<video id="v" playsinline muted></video>
<div id="gate"><div class="box">Camera permission needed — click to start</div></div>
<div id="hud"></div>

<script>
(function(){
  const v = document.getElementById('v');
  const cnv = document.getElementById('out');
  const g = cnv.getContext('2d', { willReadFrequently:true });
  const gate = document.getElementById('gate');
  const hud  = document.getElementById('hud');

  /* -------- performance knobs -------- */
  const MAX_SAMPLE_W = 640;   // downscale width for analysis
  let   GRID = 6;             // sampling step (bigger = fewer ops)
  const CAP_DPR = 1;          // cap devicePixelRatio to 1 for speed
  const TRAIL = 0.18;         // frame feedback (0..1)
  const GREEN = [140,255,200]; // display tint
  /* ----------------------------------- */

  let running = false, raf = null;
  let mode = 1;               // 1: edges, 2: flow, 3: luma-depth
  let showHUD = true;

  // canvas sizing with capped DPR
  function resize() {
    const dpr = Math.min(CAP_DPR, window.devicePixelRatio || 1);
    const w = Math.max(1, Math.floor(innerWidth  * dpr));
    const h = Math.max(1, Math.floor(innerHeight * dpr));
    cnv.width = w; cnv.height = h;
    cnv.style.width = innerWidth + 'px';
    cnv.style.height = innerHeight + 'px';
    g.setTransform(dpr,0,0,dpr,0,0);
  }
  resize(); addEventListener('resize', resize);

  // offscreen buffers
  let bufA = document.createElement('canvas');
  let gbA = bufA.getContext('2d', { willReadFrequently:true });
  let prev = null; // previous frame Uint8ClampedArray for flow

  // utils
  function luma(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }
  function clamp(v,a,b){ return v<a?a:(v>b?b:v); }

  // HUD
  function drawHUD() {
    if (!showHUD) { hud.style.display = 'none'; return; }
    hud.style.display = 'block';
    const name = mode===1?'Contour (Sobel)':
                 mode===2?'Flow Field (block-match)':
                          'Luma Depth (fake z)';
    hud.innerHTML =
      `<b>Mode:</b> ${name}<br>
       <b>Keys:</b> 1/2/3 switch • [ / ] grid ${GRID}px • H toggle HUD<br>
       <b>Notes:</b> feed this page to TD as a texture; performance scales with GRID.`;
  }

  // main loop
  function loop() {
    if (!running) return;

    // trail feedback
    g.fillStyle = `rgba(0,0,0,${TRAIL})`;
    g.fillRect(0,0,cnv.width,cnv.height);

    const vw = v.videoWidth || 640, vh = v.videoHeight || 480;

    // scale video to cover canvas; sample from downscaled buffer
    const coverScale = Math.max(cnv.width / vw, cnv.height / vh);
    const drawW = Math.min(MAX_SAMPLE_W, Math.ceil(vw * coverScale));
    const drawH = Math.ceil(drawW * (vh / vw));

    bufA.width = drawW; bufA.height = drawH;
    gbA.drawImage(v, 0, 0, drawW, drawH);
    const img = gbA.getImageData(0, 0, drawW, drawH);
    const data = img.data;

    // mapping to display
    const dispW = vw * coverScale, dispH = vh * coverScale;
    const ox = (cnv.width - dispW)/2, oy = (cnv.height - dispH)/2;
    const sx = dispW / drawW, sy = dispH / drawH;

    // common composite for glow
    const prevOp = g.globalCompositeOperation;
    g.globalCompositeOperation = 'lighter';
    g.lineCap = 'round';
    g.lineJoin = 'round';

    if (mode === 1) {
      // -------- 1) CONTOUR (SOBEL) --------
      // compute luma buffer
      const Y = new Float32Array(drawW*drawH);
      for (let y=0, i=0, p=0; y<drawH; y++){
        for (let x=0; x<drawW; x++, i++, p+=4){
          Y[i] = luma(data[p], data[p+1], data[p+2]);
        }
      }
      // Sobel kernels
      const Gx = [-1,0,1,-2,0,2,-1,0,1];
      const Gy = [-1,-2,-1,0,0,0,1,2,1];

      for (let y=1; y<drawH-1; y+=GRID){
        for (let x=1; x<drawW-1; x+=GRID){
          let sxv=0, syv=0, k=0;
          for (let j=-1;j<=1;j++){
            for (let i=-1;i<=1;i++,k++){
              const yy = y+j, xx = x+i;
              const val = Y[yy*drawW+xx];
              sxv += Gx[k]*val;
              syv += Gy[k]*val;
            }
          }
          const mag = Math.hypot(sxv, syv);
          if (mag < 60) continue; // threshold to keep crisp
          // stroke orientation = gradient angle
          const ang = Math.atan2(syv, sxv);
          const len = clamp(mag/255, 0, 1) * 6 + 2;
          const cx = ox + x*sx, cy = oy + y*sy;
          g.strokeStyle = `rgba(${GREEN[0]},${GREEN[1]},${GREEN[2]},0.8)`;
          g.lineWidth = 1.25;
          g.beginPath();
          g.moveTo(cx - Math.cos(ang)*len, cy - Math.sin(ang)*len);
          g.lineTo(cx + Math.cos(ang)*len, cy + Math.sin(ang)*len);
          g.stroke();
        }
      }

    } else if (mode === 2) {
      // -------- 2) FLOW FIELD (block-matching) --------
      // luma buffer
      const Y = new Uint8Array(drawW*drawH);
      for (let y=0, i=0, p=0; y<drawH; y++){
        for (let x=0; x<drawW; x++, i++, p+=4){
          Y[i] = luma(data[p], data[p+1], data[p+2])|0;
        }
      }
      if (prev && prev.length === Y.length){
        const search = 1; // +/- 1 px search
        for (let y=GRID; y<drawH-GRID; y+=GRID){
          for (let x=GRID; x<drawW-GRID; x+=GRID){
            // block center index
            const idx = y*drawW + x;
            // brute-force SAD over 3x3 offsets
            let bestDx = 0, bestDy = 0, bestSAD = 1e9;
            for (let dy=-search; dy<=search; dy++){
              for (let dx=-search; dx<=search; dx++){
                let sad = 0;
                // sample a tiny 3x3 block
                for (let j=-1;j<=1;j++){
                  for (let i=-1;i<=1;i++){
                    const n1 = (y+j)*drawW + (x+i);
                    const n2 = (y+j+dy)*drawW + (x+i+dx);
                    sad += Math.abs(Y[n1] - prev[n2]);
                  }
                }
                if (sad < bestSAD){ bestSAD=sad; bestDx=dx; bestDy=dy; }
              }
            }
            const mag = Math.hypot(bestDx, bestDy);
            if (mag < 0.2) continue;
            const scale = 10; // arrow length scale
            const cx = ox + x*sx, cy = oy + y*sy;
            const ex = cx + bestDx*scale, ey = cy + bestDy*scale;
            g.strokeStyle = `rgba(${GREEN[0]},${GREEN[1]},${GREEN[2]},0.9)`;
            g.lineWidth = 1.3;
            g.beginPath(); g.moveTo(cx,cy); g.lineTo(ex,ey); g.stroke();
            // arrow head
            const ang = Math.atan2(bestDy, bestDx);
            const ah = 3;
            g.beginPath();
            g.moveTo(ex,ey);
            g.lineTo(ex - Math.cos(ang+0.6)*ah, ey - Math.sin(ang+0.6)*ah);
            g.lineTo(ex - Math.cos(ang-0.6)*ah, ey - Math.sin(ang-0.6)*ah);
            g.closePath(); g.fillStyle = `rgba(${GREEN[0]},${GREEN[1]},${GREEN[2]},0.9)`; g.fill();
          }
        }
      }
      // store current frame as prev
      prev = Y;

    } else {
      // -------- 3) LUMA DEPTH (fake z warp) --------
      // draw jittered points whose y is displaced by brightness
      for (let y=0; y<drawH; y+=GRID){
        for (let x=0; x<drawW; x+=GRID){
          const i = ((y*drawW)+x)*4;
          const L = luma(data[i], data[i+1], data[i+2]);
          const z = (L/255 - 0.5) * 40; // +/- displacement
          const cx = ox + x*sx;
          const cy = oy + y*sy - z; // elevate bright points
          const r = 0.6 + (L/255)*3.8;
          const a = 0.05 + (L/255)*0.7;
          g.fillStyle = `rgba(${GREEN[0]},${GREEN[1]},${GREEN[2]},${a})`;
          g.beginPath(); g.arc(cx, cy, r, 0, Math.PI*2); g.fill();
        }
      }
    }

    g.globalCompositeOperation = prevOp;
    drawHUD();
    raf = requestAnimationFrame(loop);
  }

  async function startCam() {
    if (running) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false });
      v.srcObject = stream;
      await v.play();
      running = true; loop();
    } catch (e) {
      gate.style.display = 'grid'; // click-to-start fallback
      console.warn('Camera start failed:', e);
    }
  }

  window.addEventListener('load', startCam);
  gate.addEventListener('click', async () => { gate.style.display='none'; await startCam(); });

  // controls
  addEventListener('keydown', (e)=>{
    if (e.key==='1') mode=1;
    else if (e.key==='2') mode=2;
    else if (e.key==='3') mode=3;
    else if (e.key==='[') GRID = Math.min(24, GRID+1);
    else if (e.key===']') GRID = Math.max(2, GRID-1);
    else if (e.key==='h' || e.key==='H') showHUD=!showHUD;
    drawHUD();
  });

  drawHUD();
})();
</script>
</body>
</html>
