<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simple Image Dots + Motion Dissolve</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #out{position:fixed;inset:0;display:block;width:100vw;height:100vh}
  #v{display:none}
  #hud{position:fixed;left:10px;bottom:10px;padding:6px 8px;border:1px solid #395;border-radius:8px;background:#0008;color:#bff;font:12px ui-monospace,system-ui}
</style>
</head>
<body>
<canvas id="out"></canvas>
<video id="v" playsinline muted></video>
<div id="hud"></div>

<script>
(function(){
  const v = document.getElementById('v');
  const cnv = document.getElementById('out');
  const g = cnv.getContext('2d', { willReadFrequently:true });
  const hud = document.getElementById('hud');

  /* -------- simple knobs -------- */
  const CAP_DPR = 1;
  const MAX_SAMPLE_W = 720; // analysis width
  let BASE_GRID = 4;        // image-dot sampling step
  let EDGE_GRID = 3;        // edge sampling step
  let DOT = 1.1;            // dot size (supports <1)
  let BASE_ADD = 0.30;      // base layer brightness
  let PART_ADD = 0.30;      // particle brightness
  const TRAIL = 0.30;       // frame fade (higher = shorter trails)
  const EDGE_T = 48;        // sobel threshold
  const LIFE_STEP = 0.038;  // particle fade speed
  const V_DAMP = 0.92;      // particle damping
  let SPAWN_MULT = 1.0;     // overall spawn
  const TINT = [160,255,210];
  let showHUD = true;
  /* ------------------------------ */

  // resize (cap DPR for TD)
  function resize(){
    const dpr = Math.min(CAP_DPR, window.devicePixelRatio||1);
    const w = Math.max(1, Math.floor(innerWidth*dpr));
    const h = Math.max(1, Math.floor(innerHeight*dpr));
    cnv.width=w; cnv.height=h;
    cnv.style.width=innerWidth+'px';
    cnv.style.height=innerHeight+'px';
    g.setTransform(dpr,0,0,dpr,0,0);
  }
  resize(); addEventListener('resize', resize);

  // offscreen buffer
  const buf = document.createElement('canvas');
  const gb  = buf.getContext('2d', { willReadFrequently:true });

  // utils
  function luma(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

  // particles (simple pooled system)
  const MAX_PARTICLES = 80000;
  const px=new Float32Array(MAX_PARTICLES), py=new Float32Array(MAX_PARTICLES);
  const vx=new Float32Array(MAX_PARTICLES), vy=new Float32Array(MAX_PARTICLES);
  const life=new Float32Array(MAX_PARTICLES), size=new Float32Array(MAX_PARTICLES);
  let head=0;
  function spawn(x,y,nx,ny,mag){
    const i=head; head=(head+1)%MAX_PARTICLES;
    px[i]=x; py[i]=y;
    const spd = Math.min(1, mag/220)*0.5;   // small kick along edge normal
    vx[i]=nx*spd; vy[i]=ny*spd;
    life[i]=1.0;
    size[i]=DOT*(0.9+Math.random()*0.2);
  }

  // previous luma for simple motion bias
  let prevY=null;

  // HUD
  let fps=60, last=performance.now();
  function drawHUD(){
    if(!showHUD){ hud.style.display='none'; return; }
    hud.style.display='block';
    hud.textContent =
      `Simple Image Dots + Motion Dissolve — ${fps|0} fps
Base grid ${BASE_GRID}px • Edge grid ${EDGE_GRID}px • Dot ${DOT.toFixed(2)}px • Spawn ${SPAWN_MULT.toFixed(2)} • Bright ${(BASE_ADD).toFixed(2)}
,/. base • [/] edge • -/= dot • ;/' spawn • B/N brightness • H HUD`;
  }

  function loop(){
    const now = performance.now();
    const dt  = Math.min(50, now-last); last=now;
    fps = 1000/Math.max(1,dt);

    // fade to black (short trail)
    g.fillStyle=`rgba(0,0,0,${TRAIL})`;
    g.fillRect(0,0,cnv.width,cnv.height);

    const vw=v.videoWidth||640, vh=v.videoHeight||480;
    const coverScale=Math.max(cnv.width/vw, cnv.height/vh);
    const drawW=Math.min(MAX_SAMPLE_W, Math.ceil(vw*coverScale));
    const drawH=Math.ceil(drawW*(vh/vw));
    buf.width=drawW; buf.height=drawH;
    gb.drawImage(v,0,0,drawW,drawH);
    const data = gb.getImageData(0,0,drawW,drawH).data;

    const dispW=vw*coverScale, dispH=vh*coverScale;
    const ox=(cnv.width-dispW)/2, oy=(cnv.height-dispH)/2;
    const sx=dispW/drawW, sy=dispH/drawH;

    // build luma + motion diff (very cheap)
    const Y=new Float32Array(drawW*drawH);
    const M=prevY && prevY.length===Y.length ? prevY.slice(0) : new Float32Array(drawW*drawH);
    for(let y=0,i=0,p=0;y<drawH;y++){
      for(let x=0;x<drawW;x++,i++,p+=4){
        const L=luma(data[p],data[p+1],data[p+2]);
        Y[i]=L;
        M[i]=prevY?Math.abs(L-prevY[i]):0;
      }
    }
    prevY = Y;

    // ===== Layer A: image dots (anchoring figure) =====
    g.globalCompositeOperation='lighter';
    g.fillStyle = `rgba(${TINT[0]},${TINT[1]},${TINT[2]},${BASE_ADD})`;
    for(let y=0;y<drawH;y+=BASE_GRID){
      const row=y*drawW;
      for(let x=0;x<drawW;x+=BASE_GRID){
        const L=Y[row+x]/255;           // 0..1
        if (L<0.08) continue;           // skip dark
        // light gamma-ish boost (no pow): L*(0.6+0.4*L)
        const w=L*(0.6+0.4*L);
        if (w<0.1) continue;
        const s=DOT;
        g.fillRect(ox+x*sx, oy+y*sy, s, s);
      }
    }
    g.globalCompositeOperation='source-over';

    // ===== Layer B: motion-biased edge particles =====
    // budget tied to fps (keeps things smooth)
    let budget = fps<48 ? 10000 : 16000;

    const Gx=[-1,0,1,-2,0,2,-1,0,1], Gy=[-1,-2,-1,0,0,0,1,2,1];
    for(let y=1;y<drawH-1;y+=EDGE_GRID){
      const row=y*drawW;
      for(let x=1;x<drawW-1;x+=EDGE_GRID){
        let sxv=0, syv=0, k=0;
        for(let j=-1;j<=1;j++){
          const r=row+j*drawW;
          for(let i=-1;i<=1;i++,k++){
            const val=Y[r+x+i];
            sxv+=Gx[k]*val; syv+=Gy[k]*val;
          }
        }
        let mag=Math.hypot(sxv,syv);
        if(mag<EDGE_T) continue;

        // simple motion emphasis
        const mot = M[row+x]/128;
        mag *= (1 + 2.5*Math.min(1,mot));

        let prob = Math.min(1, (mag-EDGE_T)*0.012*SPAWN_MULT);
        if (Math.random()<prob && --budget>0){
          const len = Math.max(1e-6, Math.hypot(sxv,syv));
          const nx=sxv/len, ny=syv/len;
          const cx=ox+x*sx+(Math.random()-0.5)*sx*EDGE_GRID*0.25;
          const cy=oy+y*sy+(Math.random()-0.5)*sy*EDGE_GRID*0.25;
          spawn(cx,cy,nx,ny,mag);
        }
        if (budget<=0) break;
      }
      if (budget<=0) break;
    }

    // update + draw particles (no extra fields)
    g.globalCompositeOperation='lighter';
    g.fillStyle=`rgba(${TINT[0]},${TINT[1]},${TINT[2]},${PART_ADD})`;
    for(let i=0;i<MAX_PARTICLES;i++){
      if(life[i]<=0) continue;
      px[i]+=vx[i]; py[i]+=vy[i];
      vx[i]*=V_DAMP; vy[i]*=V_DAMP;
      life[i]-=LIFE_STEP;
      if(life[i]<=0){ life[i]=0; continue; }
      const s=DOT*(0.7+0.3*life[i]);
      g.fillRect(px[i],py[i],s,s);
    }
    g.globalCompositeOperation='source-over';

    drawHUD();
    requestAnimationFrame(loop);
  }

  // camera + controls
  async function startCam(){
    try{
      const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'},audio:false});
      v.srcObject=stream; await v.play(); loop();
    }catch(e){ console.warn('Camera start failed:', e); }
  }
  window.addEventListener('load', startCam);

  addEventListener('keydown', (e)=>{
    if(e.key===',' ) BASE_GRID = Math.min(10, BASE_GRID+1);
    else if(e.key==='.' ) BASE_GRID = Math.max(2, BASE_GRID-1);
    else if(e.key==='[' ) EDGE_GRID = Math.min(10, EDGE_GRID+1);
    else if(e.key===']' ) EDGE_GRID = Math.max(2, EDGE_GRID-1);
    else if(e.key==='-' ) DOT = Math.max(0.6, DOT-0.1);
    else if(e.key==='=' ) DOT = Math.min(2.2, DOT+0.1);
    else if(e.key===';' ) SPAWN_MULT = Math.max(0.3, SPAWN_MULT*0.9);
    else if(e.key==="'" ) SPAWN_MULT = Math.min(3.0, SPAWN_MULT*1.1);
    else if(e.key==='b'||e.key==='B'){ BASE_ADD=Math.min(0.6, BASE_ADD+0.02); PART_ADD=Math.min(0.6, PART_ADD+0.02); }
    else if(e.key==='n'||e.key==='N'){ BASE_ADD=Math.max(0.12, BASE_ADD-0.02); PART_ADD=Math.max(0.12, PART_ADD-0.02); }
    else if(e.key==='h'||e.key==='H'){ showHUD=!showHUD; }
    drawHUD();
  });

  drawHUD();
})();
</script>
</body>
</html>

